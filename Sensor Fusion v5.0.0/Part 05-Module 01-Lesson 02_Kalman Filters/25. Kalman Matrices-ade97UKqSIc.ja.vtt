WEBVTT
Kind: captions
Language: ja

00:00:00.000 --> 00:00:06.000
少し難しいプログラミングの課題を用意しました

00:00:06.000 --> 00:00:08.000
時間がかかると思いますが

00:00:08.000 --> 00:00:14.000
多次元のカルマンフィルタを実装してみてください

00:00:14.000 --> 00:00:21.000
行列クラスは行列を操作する定義なので
プログラミングを簡単にしてくれるはずです

00:00:21.000 --> 00:00:26.000
さらに行列を初期化する関数を持っています
すぐに例をお見せします

00:00:26.000 --> 00:00:29.000
値を0にセットするzero

00:00:29.000 --> 00:00:35.000
単位行列を計算するidentity
行列を出力するshow

00:00:35.000 --> 00:00:41.000
足し算のadd、引き算のsub、
掛け算のmulなどの演算関数に加え

00:00:41.000 --> 00:00:45.000
行列を転置させるtransposeを定義します

00:00:45.000 --> 00:00:51.000
拡張されたコードではコレスキー因数分解を用いて
行列を実際に反転させます

00:00:51.000 --> 00:00:57.000
ここにinverseという関数があります
この行列クラスは便利です

00:00:57.000 --> 00:01:03.000
ライブラリでよく見る関数の短いバージョンです
少し説明しましょう

00:01:03.000 --> 00:01:08.000
このように括弧の中に引数を持つコマンドで
行列を作れます

00:01:08.000 --> 00:01:12.000
二次元行列と言います
この場合は垂直ベクトルです

00:01:12.000 --> 00:01:17.000
showコマンドで
垂直ベクトルの結果を出力できます

00:01:17.000 --> 00:01:20.000
次のようにtransposeコマンドを実現します

00:01:20.000 --> 00:01:24.000
これを実行すれば水平ベクトルの値が得られます

00:01:24.000 --> 00:01:28.000
行列にベクトルを掛けたいとします

00:01:28.000 --> 00:01:31.000
この初期設定の行列
［12．，8．］と［6．，2．］

00:01:31.000 --> 00:01:34.000
2×2の行列を作れます

00:01:34.000 --> 00:01:38.000
この行列を出力するとこうなります
12、8、6、2です

00:01:38.000 --> 00:01:43.000
この部分の値です　今度はFとaを掛けましょう

00:01:43.000 --> 00:01:46.000
次の式を入れます　b＝F＊a

00:01:46.000 --> 00:01:51.000
showで出力するとベクトル200と80を得ます

00:01:51.000 --> 00:01:55.000
200は10×12＋10×8の解です

00:01:55.000 --> 00:02:00.000
そして80は10×6＋10×2の解です

00:02:00.000 --> 00:02:06.000
そこで行列ライブラリを使い初期状態を設定します

00:02:06.000 --> 00:02:12.000
一次元で位置と速度の状態を追跡しています

00:02:12.000 --> 00:02:17.000
実際の位置と速度は不明なので
0で両方を初期化しました

00:02:17.000 --> 00:02:20.000
不確実性を表す行列があります

00:02:20.000 --> 00:02:26.000
位置と速度の不確実性はかなり高くなっています

00:02:26.000 --> 00:02:31.000
しかし2つは相関しません
行列は［1000．，0．］、［0．，1000．］です

00:02:31.000 --> 00:02:37.000
外部動作を指定しますが［0．］、［0．］なので
効果はなく無視することにします

00:02:37.000 --> 00:02:42.000
次の状態関数を作ります
ちょうど話した［1．，1］と［0，1．］です

00:02:42.000 --> 00:02:47.000
速度は位置に加算されているだけと仮定するので

00:02:47.000 --> 00:02:50.000
速度と期待値は同じままです

00:02:50.000 --> 00:02:55.000
最初の2つの値1と0を引っ張ってくる
観測関数を作ります

00:02:55.000 --> 00:02:58.400
この関数で位置は観察できますが
速度はできません

00:02:58.400 --> 00:03:02.000
観測の不確実性は この例では1になります

00:03:02.000 --> 00:03:06.000
単位行列は［1．、0．］、［0．、1．］です

00:03:06.000 --> 00:03:10.000
ここで3つの要素を持つmeasurementsを用いて
filterを実行します

00:03:10.000 --> 00:03:15.000
filterを実行すると速度を推測することができます

00:03:15.000 --> 00:03:18.000
より正確な予測をすることができるのです

00:03:18.000 --> 00:03:21.000
次のフィルタ・プログラムを書いてください

00:03:21.000 --> 00:03:25.000
まず観測更新 次に動作の更新です

00:03:25.000 --> 00:03:28.000
filterを実行する度に

00:03:28.000 --> 00:03:33.000
最初に観測 次に動作の順番で更新してください

00:03:33.000 --> 00:03:37.000
ここに空のfilterプロシージャがあるので
穴を埋めましょう

00:03:37.000 --> 00:03:42.000
まずmeasurementsを調べ
次に観測と動作を更新します

00:03:42.000 --> 00:03:46.000
その後 予測させて
導き出された推定値を出力します

00:03:46.000 --> 00:03:50.000
この場合は3回同じことを行います

00:03:50.000 --> 00:03:54.000
穴を埋めたらRunボタンを押し次の出力を得ます

00:03:54.000 --> 00:03:57.000
最初の観測更新のあと

00:03:57.000 --> 00:04:04.000
位置1を観察し0．99をここへコピーしました

00:04:04.000 --> 00:04:09.000
速度は相変わらず不明で
初期化した時の0のままです

00:04:09.000 --> 00:04:13.000
そして更新された不確実性の行列があります

00:04:13.000 --> 00:04:18.000
強い相関性を示す
1000、1000、1000、1000です

00:04:18.000 --> 00:04:23.000
これは穴埋めした初期の状態から
非対角の要素が異なっています

00:04:23.000 --> 00:04:27.000
カルマンフィルタの結果とちょうど同じです

00:04:27.000 --> 00:04:31.000
もう一度2を観察します

00:04:31.000 --> 00:04:36.000
次の予測の出力は3になります　観察＋予測です

00:04:36.000 --> 00:04:41.000
今回は速度に関して とてもいい予測があります

00:04:41.000 --> 00:04:46.000
1である理由はカルマンフィルタが

00:04:46.000 --> 00:04:50.000
この値を求めるために数式を使ったためです

00:04:50.000 --> 00:04:54.000
新しい共分散行列があります

00:04:54.000 --> 00:04:58.000
予測のあとの3回目の観察です

00:04:58.000 --> 00:05:03.000
予測は正確には3．999で事実上の4です

00:05:03.000 --> 00:05:07.000
速度の予測は0．99999で約1です

00:05:07.000 --> 00:05:13.000
もう1つ不確実性の行列があり
速度の観測において高い確実性を描いています

00:05:13.000 --> 00:05:18.000
推定位置において初期の不確実性に比べると
確実性が高くなったと気づけましたか？

00:05:18.000 --> 00:05:24.400
ここの正確な値を出力する
filterアルゴリズムを書いてください

00:05:24.400 --> 00:05:28.000
これは難しい課題ですが

00:05:28.000 --> 00:05:33.000
基本的には説明した数式を実装すればいいのです

00:05:33.000 --> 00:05:39.000
まずは行列クラスに慣れてから
フィルタコードを埋めてみましょう

00:05:39.000 --> 00:05:44.000
多変数カルマンフィルタで説明したことを
思い出してください

