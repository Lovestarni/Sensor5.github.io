WEBVTT
Kind: captions
Language: zh-CN

00:00:00.260 --> 00:00:07.350
下面这个新的编程任务很有难度 你可能要多花点时间

00:00:07.440 --> 00:00:12.823
但是我希望你能根据我提供的例子 实现一个

00:00:12.823 --> 00:00:13.930
多维卡尔曼滤波器

00:00:13.930 --> 00:00:20.181
矩阵类是一个操作矩阵的类 因此不会太难

00:00:20.275 --> 00:00:26.064
它有一个初始化矩阵的函数 - 接下来我会给你举例子

00:00:26.131 --> 00:00:28.861
它可以将矩阵元素设置为 0

00:00:28.861 --> 00:00:31.130
它可以计算一个单位矩阵

00:00:31.130 --> 00:00:33.207
它可以使用 show 命令打印出一个矩阵

00:00:33.369 --> 00:00:38.170
它会重载操作符 如加法、减法、乘法

00:00:39.542 --> 00:00:45.292
甚至计算矩阵的转置

00:00:45.398 --> 00:00:49.291
在一些扩展的代码中 它还可以使用

00:00:49.291 --> 00:00:51.249
Cholesky 分解来求逆矩阵

00:00:51.249 --> 00:00:53.671
这里有个函数叫做 inverse

00:00:53.671 --> 00:00:56.131
这个矩阵类是可用的

00:00:56.131 --> 00:00:59.492
这是一个简化版的矩阵类，它的原型你可以典型的矩阵库中找到

00:00:59.629 --> 00:01:03.121
我会简单为你演示一下

00:01:03.267 --> 00:01:08.202
你可以用这样的命令 加上括号中的参数 来创建一个矩阵

00:01:08.290 --> 00:01:10.347
这是一个二维矩阵

00:01:10.369 --> 00:01:12.328
在本例中 它被叫做垂直向量

00:01:12.393 --> 00:01:17.041
使用 show 命令 可以打印出垂直向量的结果

00:01:17.077 --> 00:01:20.346
你可以如下进行转置

00:01:20.376 --> 00:01:23.779
如果你运行这个 你会发现水平向量

00:01:23.779 --> 00:01:27.353
假设你想用一个向量乘一个矩阵

00:01:27.449 --> 00:01:31.253
那么我们可以用这里的初始化做一个 2x2 的矩阵

00:01:31.253 --> 00:01:33.953
一个 [12., 8.] 和 [6., 2.] 的矩阵

00:01:33.998 --> 00:01:35.983
我们可以打印这个矩阵

00:01:35.990 --> 00:01:38.688
具体如下： 12, 8, 6, 2.

00:01:38.724 --> 00:01:40.591
这些就是这边的值

00:01:40.591 --> 00:01:42.986
我们可以把 F 乘以 a

00:01:43.028 --> 00:01:45.538
因此 这里 b = F x a.

00:01:45.691 --> 00:01:50.155
如果我们显示结果 就会得到向量 200 80

00:01:50.155 --> 00:01:56.319
具体算法是 10 x 12 + 10 x 8 结果是 200

00:01:56.330 --> 00:01:59.232
10 x 6 + 10 x 2 等于 80

00:02:01.621 --> 00:02:06.040
因此 使用我的矩阵库 我设置了一个初始状态

00:02:06.040 --> 00:02:11.038
在一维追踪场景中 状态是位置

00:02:11.038 --> 00:02:12.819
和速度

00:02:12.819 --> 00:02:17.485
我不知道实际的位置和速度 因此我把两个都初始化为 0

00:02:17.485 --> 00:02:20.178
我得到了一个不确定性矩阵

00:02:20.208 --> 00:02:23.106
其中位置的不确定性很高

00:02:23.106 --> 00:02:26.827
速度的不确定性也很高

00:02:26.827 --> 00:02:28.177
而且它们都是不相关的

00:02:28.215 --> 00:02:31.298
这是 1000, 0, 0, 1000 的矩阵

00:02:31.298 --> 00:02:34.857
我假设了一个外部运动 但是它是 0, 0 因此无效

00:02:34.903 --> 00:02:35.891
只需忽略即可

00:02:36.577 --> 00:02:40.331
我构建了下一个状态函数 就是我们刚刚讨论的

00:02:40.331 --> 00:02:42.075
[1., 1] [0, 1.].

00:02:42.075 --> 00:02:47.046
这里假设 速度和位置直接相加

00:02:47.053 --> 00:02:50.205
而且速度始终保持不变

00:02:50.391 --> 00:02:53.563
我建立了一个测量函数只提取

00:02:53.567 --> 00:02:55.491
两个值中的第一个 1 和 0

00:02:55.491 --> 00:02:58.479
这样我就可以观察位置 而不是速度

00:02:58.479 --> 00:03:00.335
我有一个测量不确定性矩阵

00:03:00.335 --> 00:03:02.262
在本例中为 1

00:03:02.262 --> 00:03:05.603
我有一个单位矩阵 [1., 0.] [0., 1.].

00:03:05.603 --> 00:03:09.406
然后 我执行滤波器，并将这三个测量值作为输入

00:03:09.406 --> 00:03:12.542
预期的结果是 当我运行滤波器时

00:03:12.542 --> 00:03:15.305
我可以估算速度

00:03:15.331 --> 00:03:18.151
从而做出更好的预测

00:03:18.163 --> 00:03:20.676
在我要求你编写的滤波器中

00:03:20.676 --> 00:03:25.775
我希望先更新测量值 然后更新运动

00:03:25.775 --> 00:03:28.438
每次运行滤波器时

00:03:28.438 --> 00:03:33.058
我希望你线更新测量值 然后才是运动

00:03:33.058 --> 00:03:37.387
这是我写的滤波器框架代码 你需要补全功能

00:03:37.387 --> 00:03:39.527
首先遍历测量数据

00:03:39.527 --> 00:03:42.687
它会更新测量值 然后更新运动

00:03:42.687 --> 00:03:46.124
和预测 然后我只需打印出预测结果即可

00:03:46.124 --> 00:03:49.705
然后重复几次 在本例中 重复 3 遍

00:03:49.705 --> 00:03:52.622
填充好之后 我点击运行按钮

00:03:52.622 --> 00:03:54.387
得到以下输出

00:03:54.387 --> 00:03:57.037
在我的第一次测量值更新后

00:03:57.037 --> 00:04:01.738
我观察到了位置 1 它被复制到

00:04:01.738 --> 00:04:04.878
了这里 变成了 0.99

00:04:04.878 --> 00:04:09.833
我对速度一无所知 因此它仍然是 0 和初始化值一样

00:04:09.864 --> 00:04:13.561
接下来 是已经更新了的不确定性矩阵

00:04:13.561 --> 00:04:17.636
它现在显示了很强的相关性

00:04:17.636 --> 00:04:19.765
1000, 1000, 1000, 1000.

00:04:19.765 --> 00:04:22.484
这和我们刚开始在非对角元素中

00:04:22.484 --> 00:04:23.924
填的初始值不一样

00:04:23.981 --> 00:04:26.942
这就是卡尔曼滤波器的功能

00:04:27.005 --> 00:04:29.160
接下来 我再次观察 2

00:04:29.160 --> 00:04:33.855
我希望输出结果告诉我 下一次预测是 4

00:04:33.855 --> 00:04:36.338
这是观察值加上预测值后的结果

00:04:36.338 --> 00:04:39.335
但现在我对速度有了一个很好

00:04:39.335 --> 00:04:41.787
的估计

00:04:41.787 --> 00:04:44.796
它肯定是 1 原因是

00:04:44.796 --> 00:04:47.432
我的卡尔曼滤波器能够使用

00:04:47.432 --> 00:04:50.774
卡尔曼滤波器方程找到这个值

00:04:50.774 --> 00:04:54.617
有一个新的协方差矩阵

00:04:54.617 --> 00:04:58.272
对于第三次观察

00:04:58.272 --> 00:05:02.637
预测是准确有效的4（3.999）

00:05:02.637 --> 00:05:07.071
速度估算是准确的1（0.99999）

00:05:07.071 --> 00:05:10.357
我还有另一个不确定性矩阵 它显示

00:05:10.357 --> 00:05:13.375
我的速度预测确定性很高

00:05:13.375 --> 00:05:16.124
注意 位置估算和初始的不确定性相比

00:05:16.124 --> 00:05:18.224
相对高了很多

00:05:18.224 --> 00:05:20.783
因此 你可以编写这个滤波器的算法

00:05:20.783 --> 00:05:25.292
并使他输出和这里一样的结果吗

00:05:25.292 --> 00:05:27.888
这个任务涉及到编程

00:05:27.888 --> 00:05:30.604
你要做的是 用代码实现我提供的

00:05:30.604 --> 00:05:32.906
方程式

00:05:32.906 --> 00:05:35.881
你必须熟悉矩阵类

00:05:35.881 --> 00:05:39.674
然后根据我向你展示的

00:05:39.674 --> 00:05:42.437
多变量卡尔曼滤波器的内容

00:05:42.437 --> 00:05:44.697
补充滤波器代码

