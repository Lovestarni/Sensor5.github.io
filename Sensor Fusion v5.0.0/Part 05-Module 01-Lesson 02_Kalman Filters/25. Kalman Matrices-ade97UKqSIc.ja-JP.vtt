WEBVTT
Kind: captions
Language: ja-JP

00:00:00.260 --> 00:00:07.350
少し難しいプログラミングの課題を用意しました

00:00:07.440 --> 00:00:12.823
時間がかかると思いますが

00:00:12.823 --> 00:00:13.930
多次元のカルマンフィルターを実装してみてください

00:00:13.930 --> 00:00:20.181
行列クラスは行列を操作する定義なので プログラミングを簡単にしてくれるはずです

00:00:20.275 --> 00:00:26.064
さらに行列を初期化する機能があるので この後 例をお見せします

00:00:26.131 --> 00:00:28.861
値を0にセットする

00:00:28.861 --> 00:00:31.130
単位行列を計算する

00:00:31.130 --> 00:00:33.207
行列を出力する

00:00:33.369 --> 00:00:38.170
加算の add 減算の sub 乗算の mulなどの演算関数に加え

00:00:39.542 --> 00:00:45.292
行列を転置させるtransposeを定義します

00:00:45.398 --> 00:00:49.291
拡張されたコードではコレスキー因数分解を使って

00:00:49.291 --> 00:00:51.249
行列を実際に反転させます

00:00:51.249 --> 00:00:53.671
ここにinverseという関数があります

00:00:53.671 --> 00:00:56.131
この行列クラスは便利です

00:00:56.131 --> 00:00:59.492
ライブラリーでよく見る関数の短い版です

00:00:59.629 --> 00:01:03.121
少し説明しましょう

00:01:03.267 --> 00:01:08.202
このように括弧の中に引数を持つコマンドで 行列を作成できます

00:01:08.290 --> 00:01:10.347
二次元行列といいます

00:01:10.369 --> 00:01:12.328
この場合は垂直ベクターです

00:01:12.393 --> 00:01:17.041
showコマンドで垂直ベクターの結果を出力できます

00:01:17.077 --> 00:01:20.346
次のようにtransposeコマンドを実現します

00:01:20.376 --> 00:01:23.779
これを実行すれば 水平ベクターの値を得られます

00:01:23.779 --> 00:01:27.353
行列にベクターを掛けるとします

00:01:27.449 --> 00:01:31.253
この初期設定の行列[12., 8.]と[6., 2.]では

00:01:31.253 --> 00:01:33.953
2x2の行列を作成できます

00:01:33.998 --> 00:01:35.983
この行列を出力すると

00:01:35.990 --> 00:01:38.688
こうなります12, 8, 6, 2.

00:01:38.724 --> 00:01:40.591
この部分の値です

00:01:40.591 --> 00:01:42.986
今度はFとaを掛けましょう

00:01:43.028 --> 00:01:45.538
b = F * aという式を挿入します

00:01:45.691 --> 00:01:50.155
showで出力するとベクター200と80が表示されます

00:01:50.155 --> 00:01:56.319
200は10×12＋10×8の解です

00:01:56.330 --> 00:01:59.232
80は10×6＋10×2の解です

00:02:01.621 --> 00:02:06.040
そこで行列ライブラリーを使い 初期状態を設定します

00:02:06.040 --> 00:02:11.038
一次元で位置と速度の状態を

00:02:11.038 --> 00:02:12.819
追跡しています

00:02:12.819 --> 00:02:17.485
実際の位置と速度は不明なので ゼロで両方を初期化しました

00:02:17.485 --> 00:02:20.178
不確実性を表す行列があります

00:02:20.208 --> 00:02:23.106
位置と速度の不確実性は

00:02:23.106 --> 00:02:26.827
かなり高くなっています

00:02:26.827 --> 00:02:28.177
しかし 2つは相関しません

00:02:28.215 --> 00:02:31.298
行列は[1000., 0.] [0., 1000.]です

00:02:31.298 --> 00:02:34.857
外部モーションを指定しますが[0.] [0.]なので

00:02:34.903 --> 00:02:35.891
効果はなく無視することにします

00:02:36.577 --> 00:02:40.331
次の状態関数を作成します  ちょうど話した

00:02:40.331 --> 00:02:42.075
[1., 1] [0, 1.]です

00:02:42.075 --> 00:02:47.046
速度は位置に加算されているだけと仮定するので

00:02:47.053 --> 00:02:50.205
速度と期待値は同じままです

00:02:50.391 --> 00:02:53.563
最初の2つの値1と0を引っ張ってくる測定関数を作ります

00:02:53.567 --> 00:02:55.491
この関数で位置は観察できますが

00:02:55.491 --> 00:02:58.479
速度は観察できません

00:02:58.479 --> 00:03:00.335
測定の不確実性は

00:03:00.335 --> 00:03:02.262
この例では1になります

00:03:02.262 --> 00:03:05.603
単位行列は[1., 0.] [0., 1.]です

00:03:05.603 --> 00:03:09.406
ここで3つの要素を持つmeasurementsを使ってfilterを実行します

00:03:09.406 --> 00:03:12.542
filterを実行すると速度を推測できます

00:03:12.542 --> 00:03:15.305
より正確に

00:03:15.331 --> 00:03:18.151
予測することができるのです

00:03:18.163 --> 00:03:20.676
次のフィルタープログラムを記述してください

00:03:20.676 --> 00:03:25.775
まず測定の更新 次にモーションの更新です

00:03:25.775 --> 00:03:28.438
filterを実行するたびに

00:03:28.438 --> 00:03:33.058
最初に測定 次にモーションの順番で更新してください

00:03:33.058 --> 00:03:37.387
ここに空のfilterプロシージャーがあるので穴を埋めましょう

00:03:37.387 --> 00:03:39.527
まずmeasurementsを調べ

00:03:39.527 --> 00:03:42.687
次に測定とモーションを更新します

00:03:42.687 --> 00:03:46.124
その後 予測させて 導き出された推定値を出力します

00:03:46.124 --> 00:03:49.705
この場合は3回同じことを行います

00:03:49.705 --> 00:03:52.622
穴を埋めたらRunボタンを押し

00:03:52.622 --> 00:03:54.387
次の出力を得ます

00:03:54.387 --> 00:03:57.037
最初の観測更新のあと

00:03:57.037 --> 00:04:01.738
位置1を観察し .99 を

00:04:01.738 --> 00:04:04.878
ここへコピーしました

00:04:04.878 --> 00:04:09.833
速度は相変わらず不明で 初期化したときのゼロのままです

00:04:09.864 --> 00:04:13.561
そして更新された不確実性の行列があります

00:04:13.561 --> 00:04:17.636
強い相関性を示す

00:04:17.636 --> 00:04:19.765
1000 1000 1000 1000です

00:04:19.765 --> 00:04:22.484
これは穴埋めした初期の状態から

00:04:22.484 --> 00:04:23.924
非対角の要素が異なっています

00:04:23.981 --> 00:04:26.942
カルマンフィルターの結果とちょうど同じです

00:04:27.005 --> 00:04:29.160
もう一度2を観察します

00:04:29.160 --> 00:04:33.855
次の予測の出力は3になります

00:04:33.855 --> 00:04:36.338
観察+予測です

00:04:36.338 --> 00:04:39.335
今回は速度に関して

00:04:39.335 --> 00:04:41.787
とてもいい予測があります

00:04:41.787 --> 00:04:44.796
1である理由はカルマンフィルターが

00:04:44.796 --> 00:04:47.432
この値を求めるために

00:04:47.432 --> 00:04:50.774
数式を使ったからです

00:04:50.774 --> 00:04:54.617
新しい共分散行列があります

00:04:54.617 --> 00:04:58.272
予測のあとの3回目の観察です

00:04:58.272 --> 00:05:02.637
予測は正確には 3.999 で事実上の4です

00:05:02.637 --> 00:05:07.071
速度の予測は0．99999で約1です

00:05:07.071 --> 00:05:10.357
もう1つ不確実性の行列があり

00:05:10.357 --> 00:05:13.375
速度の観測において高い確実性を描いています

00:05:13.375 --> 00:05:16.124
推定位置において初期の不確実性に比べると

00:05:16.124 --> 00:05:18.224
確実性が高くなったと気づきましたか?

00:05:18.224 --> 00:05:20.783
ここの正確な値を出力する

00:05:20.783 --> 00:05:25.292
filterアルゴリズムを記述してください

00:05:25.292 --> 00:05:27.888
これは難しい課題ですが

00:05:27.888 --> 00:05:30.604
基本的には説明した数式を

00:05:30.604 --> 00:05:32.906
実装すればいいのです

00:05:32.906 --> 00:05:35.881
まずは行列クラスに慣れてから

00:05:35.881 --> 00:05:39.674
フィルターコードを埋めてみましょう

00:05:39.674 --> 00:05:42.437
多変数カルマンフィルターで説明したことを

00:05:42.437 --> 00:05:44.697
思い出してください

