WEBVTT
Kind: captions
Language: ja-JP

00:00:00.280 --> 00:00:02.929
追跡アルゴリズムを実装したら
そのパフォーマンスをチェックして

00:00:02.930 --> 00:00:05.380
推定結果と

00:00:05.379 --> 00:00:10.059
実際の結果の差を確認することを
お勧めします

00:00:10.060 --> 00:00:12.700
評価メトリックはたくさんありますが

00:00:12.699 --> 00:00:17.259
おそらく最も一般的なものは
平均二乗平方根誤差です

00:00:17.260 --> 00:00:20.400
トラッキングののコンテキストでは
これは推定状態と

00:00:20.399 --> 00:00:24.959
実際の状態の偏差を測定するために使用される
精度測定基準です

00:00:24.960 --> 00:00:27.150
それでは計算方法を見てみましょう

00:00:27.149 --> 00:00:31.669
所定の処理ステップでは
基本的に推定状態と実際の値の2つの値が必要です

00:00:31.670 --> 00:00:36.630
推定状態は位置と速度のコンポーネントを含むベクターであり
実際の値は一般的に

00:00:36.630 --> 00:00:41.880
地上検証データ値として
知られています

00:00:41.880 --> 00:00:44.219
推定状態と
地上検証データとの差は

00:00:44.219 --> 00:00:47.835
残差と
呼ばれます

00:00:47.835 --> 00:00:51.539
これらの残差を二乗し
平均化し

00:00:51.539 --> 00:00:55.060
最後に平方根を計算して
誤差測定基準を求めることができます

00:00:55.060 --> 00:00:59.800
誤差が小さいほど
推定精度は高くなります

00:00:59.799 --> 00:01:02.529
C++ではどうなるでしょうか

00:01:02.530 --> 00:01:05.079
スターティングコードを用意しておきました

00:01:05.079 --> 00:01:11.049
推定状態のリストに対応する
地上検証データのリストを取得する

00:01:11.049 --> 00:01:16.109
CalculateRMSE関数を
完成させましょう

00:01:16.109 --> 00:01:20.079
この関数は
位置と速度の平均二乗平方根誤差を持つ

00:01:20.079 --> 00:01:21.159
ベクターを返します

00:01:21.159 --> 00:01:23.489
2つのベクター 推定値と地上検証データの場合は

00:01:23.489 --> 00:01:28.608
無効な入力をチェックする必要があることも
考慮してください

00:01:28.608 --> 00:01:31.549
推定ベクターは
空であってはならず

00:01:31.549 --> 00:01:34.840
地上検証データベクターと
同じサイズでなければなりません

00:01:34.840 --> 00:01:37.650
そのため 固有関数を使って
必要な演算を

00:01:37.650 --> 00:01:39.830
すべて行う必要があります

00:01:39.829 --> 00:01:44.609
この例のように ベクターをもう1つのベクターから
減算することをお勧めします

00:01:44.609 --> 00:01:49.280
このように係数ごとの乗算を実行することも
あるいはこのように

00:01:49.280 --> 00:01:52.099
ベクター要素の平方根を
計算することもできます

