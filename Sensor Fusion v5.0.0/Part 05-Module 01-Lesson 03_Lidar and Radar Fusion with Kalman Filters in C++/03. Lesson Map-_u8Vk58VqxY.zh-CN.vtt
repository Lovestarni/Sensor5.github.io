WEBVTT
Kind: captions
Language: zh-CN

00:00:00.400 --> 00:00:03.830
迄今为止 你已经学习了大量汽车传感器的知识

00:00:03.830 --> 00:00:07.470
以及如何在 Python 中实现通用滤波器

00:00:07.469 --> 00:00:11.800
按照课程要求 你也已经掌握了足够的 C++技能

00:00:11.800 --> 00:00:14.970
可以使用它编写卡尔曼滤波器

00:00:14.970 --> 00:00:18.160
在本课中 你要把所有知识结合在一起

00:00:18.160 --> 00:00:20.850
开发一个完整的数据融合模型

00:00:20.850 --> 00:00:24.730
基于卡尔曼滤波器的数据融合包括很多方面

00:00:24.730 --> 00:00:28.350
下面 我们快速了解一下

00:00:28.350 --> 00:00:30.929
如果你有点跟不上 不要担心

00:00:30.929 --> 00:00:32.850
后面我们还会看到这张图

00:00:32.850 --> 00:00:33.940
首先

00:00:33.939 --> 00:00:38.280
你需要创建一个扩展卡尔曼滤波器

00:00:38.280 --> 00:00:42.100
扩展的意思是说 它能够处理

00:00:42.100 --> 00:00:45.980
更复杂的运动模型和测量模型

00:00:45.979 --> 00:00:48.899
这里是整体处理流程

00:00:48.899 --> 00:00:53.019
你有两个传感器：激光雷达和雷达

00:00:53.020 --> 00:00:57.090
它们提供的信息用于估算

00:00:57.090 --> 00:00:58.940
移动中行人的状态

00:00:58.939 --> 00:01:04.049
状态通过二维位置和二维速度表示

00:01:04.049 --> 00:01:07.920
每次收到来自特定传感器的新测量值时

00:01:07.920 --> 00:01:10.019
都会触发估算函数

00:01:10.019 --> 00:01:16.299
在这里 我们执行两个步骤 状态预测和测量更新

00:01:16.299 --> 00:01:21.140
在预测步骤 我们在协方差中预测行人状态 以及对应的协方差矩阵

00:01:21.140 --> 00:01:25.200
具体做法是 考虑当前和前一次观察

00:01:25.200 --> 00:01:27.100
之间的时间差

00:01:27.099 --> 00:01:30.469
测量更新步骤取决于传感器类型

00:01:30.469 --> 00:01:35.179
我们会看到 有两种类型：激光和雷达

00:01:35.180 --> 00:01:39.440
如果当前观察数据来自激光传感器

00:01:39.439 --> 00:01:44.399
我们可以使用一个标准的卡尔曼滤波器来更新行人状态

00:01:44.400 --> 00:01:49.350
但是 雷达测量值需要使用非线性测量函数

00:01:49.349 --> 00:01:52.030
因此 我们收到雷达测量值时

00:01:52.030 --> 00:01:55.480
会使用不同的方法来处理测量更新

00:01:55.480 --> 00:01:56.280
例如

00:01:56.280 --> 00:02:01.480
我们可能使用扩展卡尔曼滤波器方程 后面我们会看到

00:02:01.480 --> 00:02:03.710
听起来是不是很好玩？

00:02:03.709 --> 00:02:04.649
我们开始吧

