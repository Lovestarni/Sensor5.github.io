WEBVTT
Kind: captions
Language: zh-CN

00:00:00.220 --> 00:00:04.309
我们继续接下来的编程任务 你需要

00:00:04.309 --> 00:00:08.219
实现一个卡尔曼滤波器 该滤波器可以代入

00:00:08.220 --> 00:00:10.179
激光雷达测量值并在二维平面上追踪行人

00:00:10.179 --> 00:00:11.789
这非常酷

00:00:11.789 --> 00:00:17.119
行人的状态向量使用位置 px、py

00:00:17.120 --> 00:00:18.850
和速度 vx、vy 表示

00:00:18.850 --> 00:00:20.960
我会给你一些开始代码

00:00:20.960 --> 00:00:24.950
我希望你能设置其余的卡尔曼滤波器变量

00:00:24.949 --> 00:00:30.199
这次 代码分为三个主要部分：一个KalmanFilter 类

00:00:30.199 --> 00:00:34.710
一个 tracking 类 以及一个 MeasurementPackage 类

00:00:34.710 --> 00:00:38.719
这里是 KalmanFilter 类、cpp 文件和

00:00:38.719 --> 00:00:41.019
对应的头文件

00:00:41.020 --> 00:00:45.500
这是你已经编写的代码 但整个 KalmanFilter 代码

00:00:45.500 --> 00:00:50.914
包括预测和更新函数 现在已经从追踪逻辑中分离了

00:00:50.914 --> 00:00:54.644
我们还有一个追踪类 可以创建并使用

00:00:54.645 --> 00:00:56.755
一个 KalmanFilter 对象

00:00:56.755 --> 00:01:00.875
在这个小练习里 你需要根据当前和之前测量值之前的时间差

00:01:00.875 --> 00:01:05.674
修改 F 和 Q 矩阵

00:01:05.674 --> 00:01:09.724
你可以在过程测量函数内部操作

00:01:09.724 --> 00:01:14.044
然后 你的代码就可以调用 KalmanFilter 预测和

00:01:14.045 --> 00:01:14.939
更新函数了

00:01:16.000 --> 00:01:19.719
记住 所有卡尔曼滤波器矩阵

00:01:19.719 --> 00:01:25.429
以及预测更新函数 都是kf 对象的成员

00:01:25.430 --> 00:01:29.760
这次编程作业和之前有很大差异

00:01:29.760 --> 00:01:33.990
这里 我们没有处理整个测量值列表

00:01:33.989 --> 00:01:36.539
而是最近的测量值

00:01:36.540 --> 00:01:41.170
我们在模拟一个更真实的场景

00:01:41.170 --> 00:01:46.629
在每次收到给定传感器的数据时 都会调用过程测量函数

00:01:46.629 --> 00:01:49.539
在本例中 传感器是激光扫描仪

00:01:49.540 --> 00:01:53.800
此传感器数据以包对象的形式体现

00:01:53.799 --> 00:01:57.859
这些测量包作为参数传递到过程测量

00:01:57.859 --> 00:01:58.969
函数

00:01:58.969 --> 00:02:00.379
你可以看到

00:02:00.379 --> 00:02:04.280
包属性分成不同的测量包类分组

00:02:04.280 --> 00:02:08.520
因此 这个类包括一个时间戳变量

00:02:08.520 --> 00:02:12.810
时间戳是一个时间点 说明了传感器产生测量值的时间

00:02:12.810 --> 00:02:18.199
还包括一个非变量 SensorType 它有两个选项：激光和雷达

00:02:18.199 --> 00:02:22.229
现在这不重要 因为你只能看到激光测量

00:02:22.229 --> 00:02:27.049
此还有包括了最新原始测量值的向量变量

00:02:27.050 --> 00:02:31.590
需要特别说明的是 如果测量包来自激光传感器

00:02:31.590 --> 00:02:36.909
那么原始测量向量就只包括观察到的 x 和 y 位置

00:02:36.909 --> 00:02:41.490
这是一个从测量包获取数据的例子

00:02:41.490 --> 00:02:45.760
你能看到 x、y 测量值和时间戳

00:02:45.759 --> 00:02:51.349
如果我们打印出这些值 结果就是这样

00:02:51.349 --> 00:02:55.519
x、y 测量值和时间戳

00:02:55.520 --> 00:02:58.719
分配给时间戳变量的这个大数字

00:02:58.719 --> 00:03:03.524
单位是微秒 计时开始时间是1970年 1 月 1 日 星期四

00:03:03.524 --> 00:03:08.210
很显然 这个变量会始终增加

00:03:08.210 --> 00:03:12.927
需要指出的是 在这个编程任务中 追踪代码

00:03:12.926 --> 00:03:18.229
会首先调用预测函数 然后才是测量更新函数

00:03:18.229 --> 00:03:22.849
这是因为 我们的预测取决于两次测量之间的

00:03:22.849 --> 00:03:26.609
时间差 而且时间不再固定

00:03:26.610 --> 00:03:32.490
因此 我们只有获得下次的观察时间戳之后 才能预测状态

00:03:32.490 --> 00:03:36.659
也就是说 我们必须等待下次过程测量调用

00:03:36.659 --> 00:03:41.349
然后在下次测量更新之前应用预测

00:03:41.349 --> 00:03:46.310
第一次过程测量调用在更新状态位置时

00:03:46.310 --> 00:03:51.949
只会使用第一次的 x、y 测量值 并且状态速度 vx

00:03:51.949 --> 00:03:57.719
vy 为零 因为我们假定不知道初始速度

00:03:57.719 --> 00:03:59.971
记住 如果碰到问题

00:03:59.971 --> 00:04:04.230
可以在代码注释中找到所需步骤

00:04:04.229 --> 00:04:04.840
祝你好运

