WEBVTT
Kind: captions
Language: en

00:00:00.400 --> 00:00:03.830
So far you've learned a lot
about car sensors, and

00:00:03.830 --> 00:00:07.470
also about how to implement
a Kalman filter in Python.

00:00:07.470 --> 00:00:11.800
And we also expect that you've got
enough of a grasp on C++ to the point

00:00:11.800 --> 00:00:14.970
where you can now implement
a Kalman filter in it.

00:00:14.970 --> 00:00:18.160
In this lesson you're going to
combine all of this knowledge

00:00:18.160 --> 00:00:20.850
to develop a complete fusion model.

00:00:20.850 --> 00:00:24.730
There are many pieces in a Kalman
filter based sense of fusion, so

00:00:24.730 --> 00:00:28.350
I want to quickly show you a general
map of what you'll be building.

00:00:28.350 --> 00:00:30.930
Don't worry if you don't
follow everything yet.

00:00:30.930 --> 00:00:32.850
You'll see this map again.

00:00:32.850 --> 00:00:33.940
First off,

00:00:33.940 --> 00:00:38.280
you're going to build something
called an Extended Kalman Filter.

00:00:38.280 --> 00:00:42.100
It's extended in the sense that
it will be capable of handling

00:00:42.100 --> 00:00:45.980
more complex motion models and
measurement models.

00:00:45.980 --> 00:00:48.900
And here is the overall processing flow.

00:00:48.900 --> 00:00:53.020
You have two sensors,
a lidar and a radar.

00:00:53.020 --> 00:00:57.090
The information provided by these
sensors is used to estimate the state

00:00:57.090 --> 00:00:58.940
of a moving pedestrian, and

00:00:58.940 --> 00:01:04.050
this state is represented by
a 2D position and a 2D velocity.

00:01:04.050 --> 00:01:07.920
Each time we receive new
measurements from a given sensor,

00:01:07.920 --> 00:01:10.020
the estimation function is triggered.

00:01:10.020 --> 00:01:16.300
At this point we perform two steps,
State Prediction and Measurement Update.

00:01:16.300 --> 00:01:21.140
In the Prediction step, we predict
the pedestrian state and its covariance.

00:01:21.140 --> 00:01:25.200
We do so by taking into account
the elapsed time between the current and

00:01:25.200 --> 00:01:27.100
the previous observations.

00:01:27.100 --> 00:01:30.470
The measurement update step
depends on sensor type.

00:01:30.470 --> 00:01:35.180
There are two cases that we'll see,
Laser and Radar.

00:01:35.180 --> 00:01:39.440
If the current measurements
are generated by a laser sensor,

00:01:39.440 --> 00:01:44.400
then we just apply a standard Kalman
filter to update the pedestrian's state.

00:01:44.400 --> 00:01:49.350
However, radar measurements involve
a nonlinear measurement function.

00:01:49.350 --> 00:01:52.030
So when we receive radar measurements,

00:01:52.030 --> 00:01:55.480
we use different tweaks to
handle the measurement update.

00:01:55.480 --> 00:01:56.280
For instance,

00:01:56.280 --> 00:02:01.480
we may use Extended Kalman filter
equations, which you'll see later.

00:02:01.480 --> 00:02:03.710
Does that sound like fun?

00:02:03.710 --> 00:02:04.650
Let's get started.

